#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\setcounter{MaxMatrixCols}{30}%
\usepackage{amsfonts}\usepackage{graphicx}
%TCIDATA{OutputFilter=latex2.dll}
%TCIDATA{Version=5.50.0.2953}
%TCIDATA{CSTFile=LaTeX article (bright).cst}
%TCIDATA{Created=Thursday, March 08, 2007 06:44:18}
%TCIDATA{LastRevised=Sunday, May 26, 2024 18:05:09}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=BibTeX}
%TCIDATA{<META NAME="DocumentShell" CONTENT="Standard LaTeX\Blank - Standard LaTeX Article">}
%TCIDATA{Language=American English}
%TCIDATA{ComputeDefs=
%$\varepsilon$
%$F_{V(\mathbf{A})}(x_{1},...,x_{n})=\{t_{1},...,t_{k}\}$
%}
%BeginMSIPreambleData
\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
%EndMSIPreambleData
\newtheorem{theorem}{Theorem}\newtheorem{acknowledgement}[theorem]{Acknowledgement}\newtheorem{algorithm}[theorem]{Algorithm}\newtheorem{axiom}[theorem]{Axiom}\newtheorem{case}[theorem]{Case}\newtheorem{claim}[theorem]{Claim}\newtheorem{conclusion}[theorem]{Conclusion}\newtheorem{condition}[theorem]{Condition}\newtheorem{conjecture}[theorem]{Conjecture}\newtheorem{corollary}[theorem]{Corollary}\newtheorem{criterion}[theorem]{Criterion}\newtheorem{definition}[theorem]{Definition}\newtheorem{example}[theorem]{Example}\newtheorem{exercise}[theorem]{Exercise}\newtheorem{lemma}[theorem]{Lemma}\newtheorem{notation}[theorem]{Notation}\newtheorem{problem}[theorem]{Problem}\newtheorem{proposition}[theorem]{Proposition}\newtheorem{remark}[theorem]{Remark}\newtheorem{solution}[theorem]{Solution}\newtheorem{summary}[theorem]{Summary}\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{lemma}
\end_layout

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "extension"

\end_inset

Sean 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

 y 
\begin_inset Formula $n,m\in\omega$
\end_inset

.
 Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.,
 entonces existe una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $\bar{f}:\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

,
 tal que 
\begin_inset Formula $f=\bar{f}|_{D_{f}}$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{lemma}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{proposition}
\end_layout

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "caract-dominios"

\end_inset

 
\series bold
(Caracterización de conjunto p.r.)
\series default
 Un conjunto 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 sii 
\begin_inset Formula $S$
\end_inset

 es el dominio de alguna funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\begin_inset Formula $.$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{proposition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{proof}
\end_layout

\end_inset

 Supongamos que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Rightarrow$
\end_inset

) Note que 
\begin_inset Formula $S=D_{Pred\circ\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}}$
\end_inset

.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Leftarrow$
\end_inset

) Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.,
 para cada 
\begin_inset Formula $F\in\mathrm{PR}_{k}^{\Sigma}.$
\end_inset

 El caso 
\begin_inset Formula $k=0$
\end_inset

 es facil
\begin_inset Formula $.$
\end_inset

 Supongamos el resultado vale para un 
\begin_inset Formula $k$
\end_inset

 fijo y supongamos 
\begin_inset Formula $F\in\mathrm{PR}_{k+1}^{\Sigma}.$
\end_inset

 Veremos entonces que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Hay varios casos,
 pero solo consideramos el de la composición.
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $F=g\circ[g_{1},...,g_{r}]$
\end_inset

 con 
\begin_inset Formula $g,g_{1},...,g_{r}\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

.
 Si 
\begin_inset Formula $F=\emptyset$
\end_inset

,
 entonces es claro que 
\begin_inset Formula $D_{F}=\emptyset$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Supongamos entonces que 
\begin_inset Formula $F$
\end_inset

 no es la funcion 
\begin_inset Formula $\emptyset$
\end_inset

.
 Tenemos entonces que 
\begin_inset Formula $r$
\end_inset

 es de la forma 
\begin_inset Formula $n+m$
\end_inset

 y
\begin_inset Formula 
\begin{align*}
g & :D_{g}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O\\
g_{i} & :D_{g_{i}}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega\text{, }i=1,...,n\\
g_{i} & :D_{g_{i}}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\Sigma^{\ast},i=n+1,...,n+m
\end{align*}

\end_inset

con 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

 y 
\begin_inset Formula $k,l\in\omega$
\end_inset

.
 Por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "extension"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
 hay funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $\bar{g}_{1},...,\bar{g}_{n+m}$
\end_inset

 las cuales son 
\begin_inset Formula $\Sigma$
\end_inset

-totales y cumplen
\begin_inset Formula 
\[
g_{i}=\bar{g}_{i}|_{D_{g_{i}}}\text{, para }i=1,...,n+m.
\]

\end_inset

Por hipotesis inductiva los conjuntos 
\begin_inset Formula $D_{g}$
\end_inset

,
 
\begin_inset Formula $D_{g_{i}}$
\end_inset

,
 
\begin_inset Formula $i=1,...,n+m$
\end_inset

,
 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y por lo tanto
\begin_inset Formula 
\[
S=\bigcap_{i=1}^{n+m}D_{g_{i}}
\]

\end_inset

lo es.
 Notese que
\begin_inset Formula 
\[
\chi_{D_{F}}^{\omega^{k}\times\Sigma^{\ast l}}=(\chi_{D_{g}}^{\omega^{n}\times\Sigma^{\ast m}}\circ\left[\bar{g}_{1},...,\bar{g}_{n+m}\right]\wedge\chi_{S}^{\omega^{k}\times\Sigma^{\ast l}})
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{theorem}
\end_layout

\end_inset

 
\series bold
(Neumann vence a Godel)
\series default
 Si 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva,
 entonces 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{theorem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Solo caso 
\begin_inset Formula $h=R(f,\mathcal{G})$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{proof}
\end_layout

\end_inset

 Probaremos por inducción en k que
\end_layout

\begin_layout Standard
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset

Si 
\begin_inset Formula $h\in\mathrm{R}_{k}^{\Sigma}$
\end_inset

,
 entonces 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $k=0$
\end_inset

 y 
\begin_inset Formula $h\in R_{k}^{\Sigma}$
\end_inset

 tenemos que
\end_layout

\begin_layout Standard
\begin_inset Formula $Succ=\Psi_{N1\gets N1+1}^{1,0,\#}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Pred=\Psi_{N1\gets N1\dot{-}1}^{1,0,\#}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C_{0}^{0,0}=\Psi_{N1\gets0}^{0,0,\#}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C_{\varepsilon}^{0,0}=\Psi_{P1\gets\varepsilon}^{0,0,*}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $d_{a}=\Psi_{P1\gets P1.a}^{0,1,*}\text{ para todo}a\in\Sigma$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p_{j}^{n,m}=\Psi_{N1\gets N\overline{j}}^{n,m,\#}\text{ si }j\in\left\{ 1,\dots,n\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p_{j}^{n,m}=\Psi_{P1\gets P\overline{j-n}}^{n,m,*}\text{ si }j\in\left\{ n+1,\dots,n+m\right\} $
\end_inset


\end_layout

\begin_layout Standard
Entonces para cualquier forma que tome 
\begin_inset Formula $h\in R_{k}^{\Sigma}$
\end_inset

 tenemos que va a ser 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
\end_layout

\begin_layout Standard
Supongamos (*) vale para 
\begin_inset Formula $k$
\end_inset

,
 veremos que vale para 
\begin_inset Formula $k+1$
\end_inset

.
 Sea 
\begin_inset Formula $h\in R_{k+1}^{\Sigma}-R_{k}^{\Sigma}$
\end_inset

.
 Hay varios casos,
 pero solo vamos a probarlo para 
\begin_inset Formula $h=R(f,\mathcal{G})$
\end_inset

,
 con
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}\\
\mathcal{G}_{a} & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}\text{, }a\in\Sigma
\end{align*}

\end_inset

elementos de 
\begin_inset Formula $\mathrm{R}_{k}^{\Sigma}$
\end_inset

.
 Sea 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{r}\}.$
\end_inset

 Por hipotesis inductiva,
 las funciones 
\begin_inset Formula $f$
\end_inset

,
 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

,
 
\begin_inset Formula $a\in\Sigma$
\end_inset

,
 son 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computables y por lo tanto podemos hacer el siguiente programa via el uso de macros
\begin_inset Formula 
\[
\begin{array}{rl}
 & \left[\mathrm{P}\overline{m+3}\leftarrow f(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\right]\\
\mathrm{L}\overline{r+1} & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{1}\text{ }\mathrm{GOTO}\;\mathrm{L}1\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{r}\text{ }\mathrm{GOTO}\;\mathrm{L}\bar{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+2}\\
\mathrm{L}1 & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[\mathrm{P}\overline{m+3}\leftarrow\mathcal{G}_{a_{1}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{1}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{L}\bar{r} & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[\mathrm{P}\overline{m+3}\leftarrow\mathcal{G}_{a_{r}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
\mathrm{L}\overline{r+2} & \mathrm{P}1\leftarrow\mathrm{P}\overline{m+3}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Es facil chequear que este programa computa 
\begin_inset Formula $h$
\end_inset

.
\end_layout

\begin_layout Standard
Ahora sea 
\begin_inset Formula $h'\in R_{k+1}^{\Sigma}-R_{k}^{\Sigma}$
\end_inset

.
 Supongamos 
\begin_inset Formula $h'=R(f',\mathcal{G}')$
\end_inset

 con
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f': & S_{1}\times\dots\times S_{n}\times L_{1}\times\dots\times L_{m}\to\omega\\
\mathcal{G}'_{a}: & \omega\times S_{1}\times\dots\times S_{n}\times L_{1}\times\dots\times L_{m}\times\Sigma^{*}\to\omega,a\in\Sigma
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
funciones de 
\begin_inset Formula $R_{k}^{\Sigma}$
\end_inset

 y sea 
\begin_inset Formula $\Sigma=\{a_{1},\dots,a_{r}\}$
\end_inset

.
 Nuevamente,
 por hipotesis inductiva las funciones 
\begin_inset Formula $f',\mathcal{G}'_{a}$
\end_inset

,
 
\begin_inset Formula $a\in\Sigma$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-computables y podemos hacer el siguiente programa via el uso de macros
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{rl}
 & \left[\mathrm{N}\overline{n+1}\leftarrow f(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\right]\\
\mathrm{L}\overline{r+1} & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{1}\text{ }\mathrm{GOTO}\;\mathrm{L}1\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{r}\text{ }\mathrm{GOTO}\;\mathrm{L}\bar{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+2}\\
\mathrm{L}1 & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[N\overline{n+1}\leftarrow\mathcal{G}_{a_{1}}(N\overline{n+1},\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{1}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{L}\bar{r} & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[N\overline{n+1}\leftarrow\mathcal{G}_{a_{r}}(N\overline{n+1},\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
\mathrm{L}\overline{r+2} & \mathrm{N}1\leftarrow N\overline{n+1}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Es facil ver que este programa computa a 
\begin_inset Formula $h'$
\end_inset

.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
